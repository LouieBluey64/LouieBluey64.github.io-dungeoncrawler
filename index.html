<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>CRYPT UNENDING ‚Äî FULL</title>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<style>
  :root{
    --bg:#0a0a0c; --stone:#1b1b21; --grime:#2a2a33; --torch:#ffbd6a; --blood:#b52c3b; --bone:#e0dccf; --ui:#26262f; --ghost:#9ea0b5;
    --green:#79c36a; --blue:#6fb7ff; --orange:#ffb86b; --purple:#b98cff;
  }
  html,body{margin:0;height:100%;background:var(--bg);color:#eee;font-family:ui-rounded,system-ui,-apple-system,Segoe UI,Roboto,sans-serif}
  #cv{display:block;width:100vw;height:100vh;background:#0a0a0c;image-rendering:pixelated;image-rendering:crisp-edges;touch-action:none}
  header,footer{display:none}
  /* HUD */
  #hud{position:fixed;inset:0;pointer-events:none}
  .bar{height:10px;width:160px;background:#111;border:1px solid #2b2b33;border-radius:4px;position:absolute;box-shadow:0 0 0 1px #000 inset}
  .fill{position:absolute;left:0;top:0;bottom:0;background:linear-gradient(180deg,#c23,#821b25)}
  .energy{background:linear-gradient(180deg,#4bb7ff,#2a6fa3)}
  .hunger{background:linear-gradient(180deg,#7bbd4a,#46752c)}
  #hpTxt{position:absolute;left:10px;top:10px;font-weight:900}
  #hpBar{left:90px;top:10px}
  #enBar{left:90px;top:26px}
  #huBar{left:90px;top:42px}
  #roomTxt{position:absolute;right:10px;top:10px;color:#cfd2e6;font-weight:900}
  #waveTxt{position:absolute;right:10px;top:28px;color:#ffbd6a;font-weight:900;display:none}
  #bossWrap{position:absolute;left:50%;top:10px;transform:translateX(-50%);display:none;align-items:center;gap:.5rem}
  #bossBar{height:12px;width:260px;background:#120c0f;border:1px solid #3a1c22;border-radius:6px}
  #bossFill{height:100%;width:0;background:linear-gradient(90deg,#6c1221,#b52c3b 60%,#d96a7a)}
  #bossName{font-weight:900;color:#ff9aa2;text-shadow:0 1px 0 #0006}
  /* Controls */
  .pad{position:absolute;pointer-events:auto;opacity:.92}
  #dpad{left:12px;bottom:12px;width:170px;height:170px;background:rgba(255,255,255,.06);border:1px solid #2f2f3a;border-radius:14px;display:grid;grid-template-columns:repeat(3,1fr);grid-template-rows:repeat(3,1fr);gap:6px;padding:8px}
  .d{background:rgba(255,255,255,.1);border:1px solid #3a3a45;border-radius:10px;color:#e8e8f0;font-weight:900}
  .d:active{filter:brightness(1.2);transform:translateY(1px)}
  .up{grid-column:2;grid-row:1}.down{grid-column:2;grid-row:3}.left{grid-column:1;grid-row:2}.right{grid-column:3;grid-row:2}
  #attack{right:12px;bottom:18px;width:68px;height:68px;border-radius:12px;background:rgba(255,255,255,.1);border:1px solid #3a3a45}
  #attack:after{content:"üó°Ô∏è";font-size:28px;filter:grayscale(1)}
  #ranged{right:12px;bottom:98px;width:68px;height:68px;border-radius:12px;background:rgba(255,255,255,.1);border:1px solid #3a3a45}
  #ranged:after{content:"üèπ";font-size:26px;filter:grayscale(1)}
  #dash{right:96px;bottom:58px;width:60px;height:60px;border-radius:12px;background:rgba(255,255,255,.1);border:1px solid #3a3a45}
  #dash:after{content:"üí•";font-size:24px;filter:grayscale(1)}
  #dashCd{position:absolute;inset:0;background:rgba(0,0,0,.5);border-radius:12px;display:none;align-items:center;justify-content:center;color:#ddd;font-weight:900}
  #interact{right:96px;bottom:138px;width:60px;height:60px;border-radius:12px;background:rgba(255,255,255,.1);border:1px solid #3a3a45}
  #interact:after{content:"‚úã";font-size:22px;filter:grayscale(1)}
  #potions{right:96px;bottom:208px;width:60px;height:60px;border-radius:12px;background:rgba(255,255,255,.1);border:1px solid #3a3a45}
  #potions:after{content:"üß™";font-size:22px;filter:grayscale(1)}
  /* Messages & Panels */
  #msg{position:fixed;left:50%;top:10px;transform:translateX(-50%);background:#111a;border:1px solid #2a2a33;border-radius:10px;padding:.4rem .7rem;display:none}
  #panel{position:fixed;inset:0;background:#0009;display:none;align-items:center;justify-content:center}
  .card{background:linear-gradient(180deg,#15151a,#0f0f14);border:1px solid #2a2a33;border-radius:14px;padding:16px;color:#ddd;text-align:center;max-width:640px}
  .choices{display:flex;gap:.6rem;justify-content:center;flex-wrap:wrap;margin-top:.6rem}
  .choice{pointer-events:auto;padding:.6rem .9rem;border:1px solid #3a3a45;border-radius:10px;background:#141418;cursor:pointer}
  .choice:active{transform:translateY(1px)}
  /* Intro */
  #intro{position:fixed;inset:0;background:#000;display:flex;align-items:center;justify-content:center;color:#ddd;z-index:5}
</style>
</head>
<body>
<canvas id="cv" width="320" height="180" aria-label="Dungeon canvas"></canvas>

<div id="hud">
  <div id="hpTxt">‚ô• <span id="hpVal">10</span>/10</div>
  <div id="hpBar" class="bar"><div id="hpFill" class="fill" style="width:100%"></div></div>
  <div id="enBar" class="bar"><div id="enFill" class="fill energy" style="width:100%"></div></div>
  <div id="huBar" class="bar"><div id="huFill" class="fill hunger" style="width:100%"></div></div>
  <div id="roomTxt">Room 1</div>
  <div id="waveTxt">Waves: 0</div>

  <div id="bossWrap"><div id="bossBar"><div id="bossFill"></div></div><span id="bossName"></span></div>

  <!-- Controls -->
  <div id="dpad" class="pad">
    <button class="d up">‚ñ≤</button>
    <button class="d down">‚ñº</button>
    <button class="d left">‚óÄ</button>
    <button class="d right">‚ñ∂</button>
  </div>
  <button id="attack" class="pad" aria-label="Melee"></button>
  <button id="ranged" class="pad" aria-label="Ranged"></button>
  <button id="dash" class="pad" aria-label="Dash"><div id="dashCd"></div></button>
  <button id="interact" class="pad" aria-label="Interact"></button>
  <button id="potions" class="pad" aria-label="Potions"></button>
</div>

<div id="msg"></div>
<div id="panel"><div class="card" id="panelContent"></div></div>

<!-- Intro -->
<div id="intro">
  <div class="card">
    <h2 style="margin:.2rem 0 .5rem;color:#ffbd6a">CRYPT UNENDING</h2>
    <p style="margin:.2rem 0 .6rem">A wanderer slips into a cave. A grate slams shut. The only way is down.</p>
    <button id="startBtn" class="choice">Enter the dungeon</button>
  </div>
</div>

<script>
/* ========= tiny utilities ========= */
const rand=(a,b)=>Math.random()*(b-a)+a, rint=(a,b)=>Math.floor(rand(a,b+1));
const clamp=(v,a,b)=>v<a?a:(v>b?b:v); const chance=p=>Math.random()<p;
const nowMs=()=>performance.now();

/* ========= canvas & scale ========= */
const cv=document.getElementById('cv'), cx=cv.getContext('2d');
let W=cv.width, H=cv.height, SCALE=3;
function fit(){ const vw=innerWidth, vh=innerHeight; SCALE=Math.max(1,Math.floor(Math.min(vw/W,vh/H))); cv.style.width=(W*SCALE)+'px'; cv.style.height=(H*SCALE)+'px'; }
addEventListener('resize', fit); fit();

/* ========= audio (simple beeps, iOS safe) ========= */
const Audio=(()=>{
  const ctx=new (window.AudioContext||window.webkitAudioContext)();
  let ok=false; async function resume(){ if(ctx.state!=='running'){ try{ await ctx.resume(); }catch(e){} } ok=true; }
  function tone(f=300,len=0.08,vol=0.2,type='square'){ if(!ok) return; const o=ctx.createOscillator(), g=ctx.createGain(); o.type=type; o.frequency.value=f; g.gain.value=vol; o.connect(g); g.connect(ctx.destination); const t=ctx.currentTime; g.gain.setValueAtTime(vol,t); g.gain.exponentialRampToValueAtTime(0.0001,t+len); o.start(t); o.stop(t+len+0.02); }
  return {resume, slash:()=>tone(520,0.07,0.2,'square'), thud:()=>tone(90,0.12,0.25,'sine'), hurt:()=>tone(160,0.15,0.3,'triangle'), heal:()=>tone(760,0.12,0.22,'sine'), pickup:()=>tone(880,0.08,0.22,'square')};
})();

/* ========= DOM refs ========= */
const hpVal=document.getElementById('hpVal'), hpFill=document.getElementById('hpFill'), enFill=document.getElementById('enFill'), huFill=document.getElementById('huFill');
const roomTxt=document.getElementById('roomTxt'), waveTxt=document.getElementById('waveTxt');
const bossWrap=document.getElementById('bossWrap'), bossFill=document.getElementById('bossFill'), bossName=document.getElementById('bossName');
const msgEl=document.getElementById('msg');
function toast(t,ms=1300){ msgEl.textContent=t; msgEl.style.display='block'; clearTimeout(toast.t); toast.t=setTimeout(()=>msgEl.style.display='none',ms); }

/* ========= game constants ========= */
const TILE=16, RW=20, RH=12; // tiles per room (rendered)
const T={FLOOR:0,WALL:1,DOOR:2,TORCH:3,DRIP:4,POOL:5,CHEST:6,LEVER:7,SECRETD:8,LOCK:9};
const ENK={SLIME:'slime', SKEL:'skeleton', BRUTE:'brute', ARCH:'archer', BAT:'bat', MAGE:'mage', BOSS:'boss', BOLT:'bolt', LOOT:'loot', AOE:'aoe', HEX:'hex'};
const LOOT={TRASH:'trash', FOOD:'food', SWORD:'sword', XBOW:'xbow', SHIELD:'shield', POT:'pot', ENCHANT:'ench'};
const ENCHANTS=['sharp','vamp','swift','endless']; // endless = infinite durability (also all boss drops have infinite)

/* ========= player & state ========= */
let roomIdx=1, map=[], ents=[], wavesActive=false, wavesLeft=0, wavesLock=false, boss=null, npcShown=false;
const player={
  x:RW/2, y:RH/2, spd:3.0, baseSpd:3.0,
  hp:10, hpMax:10, energy:100, energyMax:100, hunger:10, hungerMax:10,
  facing:[1,0],
  melee:false, meleeDur:0, ranged:false, rangedDur:0,
  enchant:null,            // applied to weapon (sharp/vamp/swift/endless)
  weakTimer:0,             // weakness effect (reduced damage)
  dashCd:0, comboClicks:0, lastMelee:0, comboSlowTimer:0
};
let shieldBlocks=0;
let hungerTimer=0, hpRegenTimer=0;

/* ========= controls ========= */
const keys={}; addEventListener('keydown', e=>{ keys[e.key]=true; if(e.key===' ') doDash(); }); addEventListener('keyup', e=>{ keys[e.key]=false; });
const dpad=document.getElementById('dpad');
[['.up','ArrowUp'],['.down','ArrowDown'],['.left','ArrowLeft'],['.right','ArrowRight']].forEach(([sel,key])=>{
  const b=dpad.querySelector(sel); b.addEventListener('touchstart',e=>{e.preventDefault();keys[key]=true},{passive:false});
  b.addEventListener('touchend',e=>{e.preventDefault();keys[key]=false},{passive:false});
  b.addEventListener('mousedown',e=>{e.preventDefault();keys[key]=true}); b.addEventListener('mouseup',()=>keys[key]=false); b.addEventListener('mouseleave',()=>keys[key]=false);
});
const dashBtn=document.getElementById('dash'), dashCdEl=document.getElementById('dashCd'), atkBtn=document.getElementById('attack'), rngBtn=document.getElementById('ranged'), intBtn=document.getElementById('interact'), potBtn=document.getElementById('potions');
dashBtn.addEventListener('click',()=>doDash());
atkBtn.addEventListener('click',()=>doMelee());
let rHeld=false, rStart=0; rngBtn.addEventListener('touchstart',e=>{e.preventDefault();rHeld=true;rStart=nowMs()},{passive:false});
rngBtn.addEventListener('touchend',e=>{e.preventDefault(); if(rHeld) doRanged(nowMs()-rStart); rHeld=false; },{passive:false});
rngBtn.addEventListener('mousedown',()=>{rHeld=true;rStart=nowMs()}); addEventListener('mouseup',()=>{ if(rHeld) doRanged(nowMs()-rStart); rHeld=false; });
intBtn.addEventListener('click',()=>doInteract());
potBtn.addEventListener('click',()=>openPotions());

/* swipe to dash too */
let swiping=false, sx=0, sy=0;
cv.addEventListener('touchstart',e=>{ if(e.touches.length===1){swiping=true; sx=e.touches[0].clientX; sy=e.touches[0].clientY;}},{passive:true});
cv.addEventListener('touchend',e=>{ if(!swiping) return; swiping=false; const t=e.changedTouches[0]; const dx=t.clientX-sx, dy=t.clientY-sy; if(Math.hypot(dx,dy)>60){ doDash(Math.atan2(dy,dx)); }}, {passive:true});

/* ========= dungeon generation ========= */
function regenRoom(isBoss=false){
  map = Array.from({length:RH},()=>Array(RW).fill(T.FLOOR));
  // border walls
  for(let y=0;y<RH;y++) for(let x=0;x<RW;x++){ if(x===0||y===0||x===RW-1||y===RH-1) map[y][x]=T.WALL; }
  // random pillars & drips
  for(let i=0;i<rint(6,12);i++){ const x=rint(2,RW-3), y=rint(2,RH-3); map[y][x]= chance(0.7)?T.WALL:T.DRIP; }
  // torches
  for(let i=0;i<rint(4,7);i++){ const side=rint(0,3); let x=1,y=1; if(side===0){x=rint(2,RW-3);y=1} if(side===1){x=rint(2,RW-3);y=RH-2} if(side===2){x=1;y=rint(2,RH-3)} if(side===3){x=RW-2;y=rint(2,RH-3)}; map[y][x]=T.TORCH; }
  // door to next (unlocked)
  const side=rint(0,3); if(side===0) map[0][rint(3,RW-4)]=T.DOOR; if(side===1) map[RH-1][rint(3,RW-4)]=T.DOOR; if(side===2) map[rint(3,RH-4)][0]=T.DOOR; if(side===3) map[rint(3,RH-4)][RW-1]=T.DOOR;
  // pool every 10th (energy restore)
  if(!isBoss && roomIdx%10===0) map[rint(3,RH-4)][rint(3,RW-4)]=T.POOL; else if(!isBoss && chance(0.28)) map[rint(3,RH-4)][rint(3,RW-4)]=T.POOL;
  // secret room & lever
  if(!isBoss && chance(0.25)){ // hidden wall (SECRETD) + lever nearby
    const sx=rint(3,RW-4), sy=rint(3,RH-4); map[sy][sx]=T.SECRETD;
    const lx=clamp(sx+rint(-3,3),2,RW-3), ly=clamp(sy+rint(-3,3),2,RH-3); map[ly][lx]=T.LEVER;
  }
  // chest
  if(!isBoss){ if(roomIdx%10===0) map[rint(3,RH-4)][rint(3,RW-4)]=T.CHEST; else if(chance(0.35)) map[rint(2,RH-3)][rint(2,RW-3)]=T.CHEST; }

  ents.length=0; boss=null; wavesActive=false; wavesLeft=0; wavesLock=false;
  // waves 5% after room > 10
  if(!isBoss && roomIdx>10 && chance(0.05)){ wavesActive=true; const depth=Math.min(1,(roomIdx-10)/120); wavesLeft=rint(2,2+Math.round(3*depth)); lockExit(); startWave(); toast('A wave seals the exits!',1600); }
  else if(!isBoss) spawnRoomEnemies(); else boss=makeBoss(Math.min(2,Math.floor(roomIdx/50)-1));

  // spawn player
  player.x=RW/2; player.y=RH/2;
}
function lockExit(){ for(let y=0;y<RH;y++)for(let x=0;x<RW;x++){ if(map[y][x]===T.DOOR) map[y][x]=T.LOCK; } }
function unlockExit(){ for(let y=0;y<RH;y++)for(let x=0;x<RW;x++){ if(map[y][x]===T.LOCK) map[y][x]=T.DOOR; } }
function spawnRoomEnemies(){
  const d=Math.min(1,(roomIdx-1)/120), n=rint((roomIdx===1?0:1), Math.round(1+d*5));
  for(let i=0;i<n;i++) spawnEnemy(pickEnemy(d));
}
function startWave(){
  ents = ents.filter(e=>!e.enemy); // clear leftovers
  const depth=Math.min(1,(roomIdx-10)/150), packs=rint(2,4);
  for(let i=0;i<packs;i++) spawnEnemy(pickEnemy(depth));
}

/* ========= enemies & bosses ========= */
function pickEnemy(d){ // weights shift with depth
  const w = [
    {k:ENK.SLIME, w:0.45 - 0.35*d},
    {k:ENK.SKEL,  w:0.35 + 0.2*d},
    {k:ENK.ARCH,  w:0.08 + 0.15*d},
    {k:ENK.MAGE,  w:0.04 + 0.18*d},
    {k:ENK.BAT,   w:0.05 + 0.1*d},
    {k:ENK.BRUTE, w:0.03 + 0.12*d},
  ].filter(x=>x.w>0.001);
  const sum=w.reduce((a,b)=>a+b.w,0); let r=Math.random()*sum;
  for(const it of w){ if((r-=it.w)<=0) return it.k; } return ENK.SLIME;
}
function spawnEnemy(kind){
  const x=rint(2,RW-3), y=rint(2,RH-3);
  const e={enemy:true, kind,x,y,vx:0,vy:0, cooldown:0, hp:1, dmg:0, ttl:999999};
  if(kind===ENK.SLIME){ e.hp=1; e.dmg=0; e.sp=0.4; }
  if(kind===ENK.SKEL){ e.hp=3; e.dmg=1; e.sp=0.6; }
  if(kind===ENK.ARCH){ e.hp=2; e.dmg=1; e.sp=0.5; e.range=true; }
  if(kind===ENK.MAGE){ e.hp=3; e.dmg=1; e.sp=0.5; e.hex=true; }
  if(kind===ENK.BAT){ e.hp=1; e.dmg=1; e.sp=0.9; e.fly=true; }
  if(kind===ENK.BRUTE){ e.hp=6; e.dmg=2; e.sp=0.45; }
  ents.push(e);
}
function makeBoss(i){
  const names=["Warden of Chains","Marrow Sovereign","The Heart Below"];
  const hp=[30,55,85][i], phases=i+1;
  return {name:names[i]||"Depth Horror", hp:hp, hpMax:hp, phase:1, phases, x:RW/2, y:rint(3,RH-4), cd:0, pattern:0};
}

/* ========= loot ========= */
function dropLoot(from, forceBoss=false){
  const d=from.kind; // enemy type or 'boss'
  let drop={kind:ENK.LOOT,x:from.x,y:from.y,ttl:9000, what:LOOT.TRASH, meta:null};
  if(d===ENK.SLIME){ drop.what= chance(0.05)?LOOT.FOOD:LOOT.TRASH; }
  if(d===ENK.SKEL){ drop.what= chance(0.05)?LOOT.SWORD:LOOT.TRASH; drop.meta= chance(0.05)?{ench:pickEnchant()}:null; }
  if(d===ENK.BRUTE){ drop.what= chance(0.10)?LOOT.SHIELD:LOOT.TRASH; }
  if(d===ENK.ARCH){ drop.what= chance(0.07)?LOOT.XBOW:LOOT.TRASH; }
  if(d===ENK.MAGE){ drop.what= chance(0.08)?LOOT.POT:LOOT.TRASH; }
  if(d===ENK.BAT){ drop.what= LOOT.TRASH; }
  // deeper: chance enchanted
  if(roomIdx>40 && drop.what===LOOT.SWORD && !drop.meta && chance(0.2)) drop.meta={ench:pickEnchant()};
  if(drop.what===LOOT.POT && !drop.meta) drop.meta={pot:pickPotion()};
  if(forceBoss){ drop.what= LOOT.ENCHANT; drop.meta={ench:'endless'}; } // unbreakable legendary
  ents.push(drop);
}
function pickEnchant(){ return ENCHANTS[rint(0,ENCHANTS.length-1)]; }
function pickPotion(){ return ['speed','strength','heart','feast','vigor'][rint(0,4)]; }

/* ========= drawing (tilted view look) ========= */
function rect(x,y,w,h,c){ cx.fillStyle=c; cx.fillRect(x,y,w,h); }
function drawScene(){
  // ‚Äútilt‚Äù illusion: draw floor, then wall face
  for(let y=0;y<RH;y++){
    for(let x=0;x<RW;x++){
      const t=map[y][x], px=x*TILE, py=y*TILE;
      // floor
      rect(px,py,TILE,TILE, (t===T.FLOOR||t===T.DRIP||t===T.POOL||t===T.CHEST||t===T.LEVER||t===T.SECRETD)?'#121216':'#121216');
      // torch glow faint
      if(t===T.TORCH){ cx.globalAlpha=0.18; rect(px-6,py-6,28,28,'#ffb84d'); cx.globalAlpha=1; }
    }
  }
  // walls & details
  for(let y=0;y<RH;y++){
    for(let x=0;x<RW;x++){
      const t=map[y][x], px=x*TILE, py=y*TILE;
      if(t===T.WALL){ rect(px,py,TILE,TILE,'#17171b'); rect(px,py+TILE-3,TILE,3,'#0d0e12'); }
      if(t===T.DRIP){ rect(px+7,py+2,2,12,'#151822'); }
      if(t===T.POOL){ rect(px+2,py+3,12,11,'#0a2a3e'); rect(px+3,py+6,10,6,'#1d5b86'); }
      if(t===T.CHEST){ rect(px+3,py+8,10,6,'#3a2816'); rect(px+3,py+5,10,4,'#714b22'); rect(px+7,py+9,2,2,'#cfa85b'); }
      if(t===T.LEVER){ rect(px+6,py+6,4,8,'#444'); rect(px+5,py+5,6,2,'#cfa85b'); }
      if(t===T.SECRETD){ /* looks like wall until toggled; we draw faint seam */ rect(px,py,TILE,TILE,'#17171b'); rect(px+6,py,4,16,'#141419'); }
      if(t===T.TORCH){ rect(px+6,py+4,4,10,'#3a2a12'); rect(px+6,py+2,4,3, Math.random()>0.5?'#ffcf7d':'#ffb84d'); }
      if(t===T.DOOR){ rect(px,py,TILE,TILE,'#231a12'); rect(px+4,py+2,8,12,'#5a3a20'); }
      if(t===T.LOCK){ rect(px,py,TILE,TILE,'#180e10'); rect(px+4,py+2,8,12,'#3a2420'); rect(px+7,py+7,2,2,'#cfa85b'); }
    }
  }
  // entities
  // player
  drawPlayer();
  // enemies & projectiles & loot
  ents.forEach(e=>{
    if(e.enemy){
      if(e.kind===ENK.SLIME) drawSlime(e);
      if(e.kind===ENK.SKEL) drawSkeleton(e);
      if(e.kind===ENK.ARCH) drawArcher(e);
      if(e.kind===ENK.MAGE) drawMage(e);
      if(e.kind===ENK.BAT)  drawBat(e);
      if(e.kind===ENK.BRUTE)drawBrute(e);
    } else {
      if(e.kind===ENK.BOLT) drawBolt(e);
      if(e.kind===ENK.AOE)  drawAOE(e);
      if(e.kind===ENK.HEX)  drawHex(e);
      if(e.kind===ENK.LOOT) drawLoot(e);
    }
  });
  if(boss) drawBoss(boss);
}
function drawPlayer(){
  const px=Math.round(W/2), py=Math.round(H/2);
  rect(px-4,py-6,8,10,'#e0dccf'); rect(px-4,py-8,8,3,'#9d9b90'); cx.globalAlpha=.3; rect(px-5,py+4,10,3,'#000'); cx.globalAlpha=1;
}
function drawSlime(e){ const px=e.x*TILE, py=e.y*TILE; rect(px-5,py-4,10,8,'#233'); rect(px-5,py-6,10,2,'#355'); }
function drawSkeleton(e){ const px=e.x*TILE, py=e.y*TILE; rect(px-4,py-6,8,10,'#e0dccf'); rect(px-4,py-8,8,3,'#555'); }
function drawBrute(e){ const px=e.x*TILE, py=e.y*TILE; rect(px-6,py-6,12,12,'#4b2a2f'); rect(px-6,py-8,12,3,'#8c3a45'); }
function drawArcher(e){ const px=e.x*TILE, py=e.y*TILE; rect(px-4,py-6,8,10,'#d2c9b8'); rect(px-4,py-8,8,3,'#4a3a2a'); rect(px+3,py-2,2,6,'#885522'); }
function drawMage(e){ const px=e.x*TILE, py=e.y*TILE; rect(px-4,py-6,8,10,'#c7b7ff'); rect(px-4,py-8,8,3,'#5a4a8f'); }
function drawBat(e){ const px=e.x*TILE, py=e.y*TILE; rect(px-3,py-3,6,6,'#2a2a33'); rect(px-7,py-1,4,2,'#2a2a33'); rect(px+3,py-1,4,2,'#2a2a33'); }
function drawBolt(e){ rect(e.x*TILE-1,e.y*TILE-1,2,2,'#bcd1ff'); }
function drawAOE(e){ cx.globalAlpha=.25; rect(e.x*TILE-12,e.y*TILE-12,24,24,'#6c1221'); cx.globalAlpha=1; }
function drawHex(e){ cx.globalAlpha=.25; rect(e.x*TILE-10,e.y*TILE-10,20,20,'#b98cff'); cx.globalAlpha=1; }
function drawLoot(e){ const px=e.x*TILE, py=e.y*TILE; let c='#444'; if(e.what===LOOT.FOOD)c='#79c36a'; if(e.what===LOOT.SWORD)c='#cfa85b'; if(e.what===LOOT.XBOW)c='#c9d4ff'; if(e.what===LOOT.SHIELD)c='#9ea0b5'; if(e.what===LOOT.POT)c='#b98cff'; if(e.what===LOOT.ENCHANT)c='#ffdf84'; rect(px-3,py-3,6,6,c); }
function drawBoss(b){ const px=b.x*TILE, py=b.y*TILE; rect(px-8,py-8,16,16,'#3a0f16'); rect(px-8,py-10,16,4,'#6c1221'); }

/* ========= UI updates ========= */
function updateBars(){
  hpVal.textContent=player.hp;
  hpFill.style.width=(player.hp/player.hpMax*100)+'%';
  enFill.style.width=(player.energy/player.energyMax*100)+'%';
  huFill.style.width=(player.hunger/player.hungerMax*100)+'%';
  roomTxt.textContent='Room '+roomIdx;
  if(boss){ bossWrap.style.display='flex'; bossFill.style.width=(boss.hp/boss.hpMax*100)+'%'; bossName.textContent=boss.name+' ‚Äî Phase '+boss.phase+'/'+boss.phases; } else bossWrap.style.display='none';
  waveTxt.style.display = wavesActive ? 'block' : 'none'; if(wavesActive) waveTxt.textContent='Waves: '+wavesLeft;
}

/* ========= collisions & helpers ========= */
function walkable(tx,ty){ return tx>0&&ty>0&&tx<RW-1&&ty<RH-1 && map[ty][tx]!==T.WALL && map[ty][tx]!==T.SECRETD; }

/* ========= combat & actions ========= */
function baseMeleeDmg(){ let d = player.melee ? 2 : 1; if(player.weakTimer>0) d=Math.max(1,Math.floor(d*0.6)); if(player.enchant==='sharp') d+=1; return d; }
function doMelee(){
  const t=nowMs(); if(t - player.lastMelee < 160) player.comboClicks++; else player.comboClicks=1; player.lastMelee=t;
  let dmg = baseMeleeDmg();
  if(player.comboClicks>=3){ dmg*=2; player.comboClicks=0; player.comboSlowTimer=1800; toast('Combo! x2 dmg (strength wanes)'); player.spd=Math.max(2.4,player.spd-0.3); }
  Audio.slash();
  hitCone(player.x,player.y,player.facing,1.0,dmg);
  if(player.melee){ if(player.enchant!=='endless'){ player.meleeDur--; if(player.meleeDur<=0){ player.melee=false; toast('Your sword shatters!'); } } }
}
function hitCone(x,y,dir,range,dmg){
  ents.forEach(e=>{
    if(e.enemy && e.hp>0){
      const dx=e.x-x, dy=e.y-y, dist=Math.hypot(dx,dy);
      if(dist<=range+0.6){ const dot=(dx*dir[0]+dy*dir[1])/Math.max(0.001,dist); if(dot>-0.2){ e.hp-=dmg; if(e.hp<=0) onEnemyDie(e); if(player.enchant==='vamp'){ player.hp=Math.min(player.hpMax,player.hp+1); } } }
    }
  });
  if(boss){ const dx=boss.x-x, dy=boss.y-y, dist=Math.hypot(dx,dy), dot=(dx*dir[0]+dy*dir[1])/Math.max(0.001,dist); if(dist<=range+1.0 && dot>-0.2){ boss.hp-=dmg; if(boss.hp<=0) nextBossPhaseOrDie(); } }
}
function doRanged(heldMs){
  if(!player.ranged){ toast('No crossbow yet!'); return; }
  // must be ‚â•5 tiles away target
  let target=null, best=999;
  ents.forEach(e=>{ if(e.enemy&&e.hp>0){ const d=Math.hypot(e.x-player.x,e.y-player.y); if(d>=5&&d<best){best=d;target=e;} }});
  if(!target){ toast('Must be at least 5m away!'); return; }
  const ang=Math.atan2(target.y-player.y,target.x-player.x);
  ents.push({kind:ENK.BOLT,x:player.x,y:player.y,vx:Math.cos(ang)*0.45,vy:Math.sin(ang)*0.45,ttl:140,dmg: (player.weakTimer>0?2:3) + (player.enchant==='sharp'?1:0)});
  Audio.pickup();
  if(player.enchant!=='endless'){ player.rangedDur--; if(player.rangedDur<=0){ player.ranged=false; toast('Your crossbow snaps!'); } }
}
function doDash(dirAng){
  if(player.dashCd>0){ toast('Dash reloading‚Ä¶'); return; }
  if(player.energy<15){ toast('Too tired to dash'); return; }
  Audio.thud();
  const dir = dirAng!=null ? [Math.cos(dirAng), Math.sin(dirAng)] : player.facing;
  player.x+=dir[0]*1.2; player.y+=dir[1]*1.2;
  hitCone(player.x,player.y,dir,1.2,2);
  player.energy=Math.max(0,player.energy-20);
  player.dashCd=10000; dashCdEl.style.display='flex';
}

/* ========= interactions ========= */
function doInteract(){
  // check within 1 tile of lever, chest, secret door
  const px=Math.round(player.x), py=Math.round(player.y);
  let did=false;
  for(let y=py-1;y<=py+1;y++)for(let x=px-1;x<=px+1;x++){
    if(y<0||y>=RH||x<0||x>=RW) continue;
    const t=map[y][x];
    if(t===T.LEVER){ map[y][x]=T.FLOOR; // open nearest secret door
      for(let yy=1;yy<RH-1;yy++)for(let xx=1;xx<RW-1;xx++){ if(map[yy][xx]===T.SECRETD){ map[yy][xx]=T.FLOOR; toast('A hidden wall grinds open‚Ä¶'); did=true; break; } } if(!did){ toast('The lever clanks.'); did=true; } }
    else if(t===T.CHEST){ openChest(x,y); map[y][x]=T.FLOOR; did=true; }
    else if(t===T.SECRETD){ map[y][x]=T.FLOOR; toast('You pry open a hidden seam.'); did=true; }
  }
  if(!did) toast("There's nothing there");
}

/* ========= chest & potions ========= */
function openChest(cx,cy){
  if(roomIdx%10===0){
    // Provision chest + choice
    openPanel(`<h3 style="margin:.2rem 0;color:#ffbd6a">Provision Chest</h3><p>Food to fill your hunger bar.</p>`,[
      {label:'Eat now (Hunger full)', on:()=>{ player.hunger=player.hungerMax; Audio.pickup(); }},
      {label:'Save (drop food)', on:()=>{ ents.push({kind:ENK.LOOT,x:cx+0.8,y:cy,ttl:9000,what:LOOT.FOOD}); }}
    ]);
    openPanel(`<p>Choose one:</p>`,[
      {label:'Shield (3 blocks)', on:()=>{ shieldBlocks+=3; }},
      {label: player.ranged ? 'Sword (dur 30)' : 'Crossbow (dur 20)', on:()=>{ if(!player.ranged){ player.ranged=true; player.rangedDur=20; } else { player.melee=true; player.meleeDur=30; } }}
    ]);
  } else {
    const roll=Math.random();
    if(roll<0.45) ents.push({kind:ENK.LOOT,x:cx+0.6,y:cy,ttl:9000,what:LOOT.FOOD});
    else if(roll<0.65) ents.push({kind:ENK.LOOT,x:cx+0.6,y:cy,ttl:9000,what:LOOT.SWORD, meta: (roomIdx>40&&chance(0.3)?{ench:pickEnchant()}:null)});
    else if(roll<0.8) ents.push({kind:ENK.LOOT,x:cx+0.6,y:cy,ttl:9000,what:LOOT.SHIELD});
    else if(roll<0.92) ents.push({kind:ENK.LOOT,x:cx+0.6,y:cy,ttl:9000,what:LOOT.XBOW});
    else ents.push({kind:ENK.LOOT,x:cx+0.6,y:cy,ttl:9000,what:LOOT.POT, meta:{pot:pickPotion()}});
    toast('You open the chest‚Ä¶');
  }
}
function openPotions(){
  openPanel(`<h3>Potions</h3><p>Tap to drink:</p>`,[
    {label:'Speed (+swift 20s)', on:()=>{ player.spd=player.baseSpd+1.2; setTimeout(()=>player.spd=player.baseSpd,20000); toast('Feet fleet.'); }},
    {label:'Strength (+dmg 20s)', on:()=>{ player.weakTimer=-20000; setTimeout(()=>player.weakTimer=0,20000); toast('Blood stirs.'); }},
    {label:'Heart (+2 HP)', on:()=>{ player.hp=Math.min(player.hpMax,player.hp+2); Audio.heal(); }},
    {label:'Feast (Hunger full)', on:()=>{ player.hunger=player.hungerMax; }},
    {label:'Vigor (Energy full)', on:()=>{ player.energy=player.energyMax; }}
  ]);
}

/* ========= panels ========= */
const panel=document.getElementById('panel'), panelContent=document.getElementById('panelContent');
function openPanel(html, choices){
  panelContent.innerHTML = html + (choices? `<div class="choices">${choices.map((c,i)=>`<button class="choice" data-i="${i}">${c.label}</button>`).join('')}</div>` : '');
  panel.style.display='flex';
  if(choices){ panelContent.querySelectorAll('.choice').forEach((b,i)=>b.addEventListener('click',()=>{ panel.style.display='none'; choices[i].on(); })); }
  else panel.addEventListener('click',()=>panel.style.display='none',{once:true});
}

/* ========= enemy updates ========= */
function onEnemyDie(e){
  dropLoot(e,false);
  e.enemy=false; e.kind='dead';
}
function enemyAI(dt){
  ents.forEach(e=>{
    if(!e.enemy) return;
    const sp = e.sp || 0.5;
    const dx=player.x-e.x, dy=player.y-e.y, d=Math.hypot(dx,dy);
    if(!e.fly){ // basic wall avoidance
      const nx = e.x + (dx/d)*sp*dt, ny = e.y + (dy/d)*sp*dt;
      if(walkable(Math.round(nx),Math.round(e.y))) e.x=nx;
      if(walkable(Math.round(e.x),Math.round(ny))) e.y=ny;
    } else { e.x += (dx/d)*sp*dt; e.y += (dy/d)*sp*dt; }
    e.cooldown-=dt;
    if(e.kind===ENK.ARCH && e.cooldown<=0 && d>4){
      const ang=Math.atan2(player.y-e.y,player.x-e.x); ents.push({kind:ENK.BOLT,x:e.x,y:e.y,vx:Math.cos(ang)*0.35,vy:Math.sin(ang)*0.35,ttl:200,dmg:1});
      e.cooldown=1400;
    } else if(e.kind===ENK.MAGE && e.cooldown<=0){
      // hex (weakness) or instant damage AOE
      if(chance(0.5)) ents.push({kind:ENK.HEX,x:player.x,y:player.y,ttl:600});
      else ents.push({kind:ENK.AOE,x:player.x,y:player.y,ttl:500,dmg:1});
      e.cooldown=1500;
    } else if(d<0.9 && e.cooldown<=0 && e.dmg>0){
      damagePlayer(e.dmg); e.cooldown=1200;
    }
  });
  // projectiles & fields
  ents.forEach(e=>{
    if(e.kind===ENK.BOLT){ e.x+=e.vx*dt; e.y+=e.vy*dt; e.ttl-=dt;
      // collide with enemies (player bolts handled in doRanged; here both can hit)
      // if enemy bolt near player
      if(Math.hypot(e.x-player.x,e.y-player.y)<0.6 && e.dmg){ damagePlayer(e.dmg); e.ttl=0; }
      ents.forEach(t=>{ if(t.enemy && Math.hypot(t.x-e.x,t.y-e.y)<0.6 && !e.fromEnemy){ t.hp-=e.dmg; e.ttl=0; if(t.hp<=0) onEnemyDie(t);} });
      if(e.ttl<=0) e.kind='dead';
    }
    if(e.kind===ENK.AOE){ e.ttl-=dt; if(e.ttl>0 && Math.hypot(player.x-e.x,player.y-e.y)<1.2){ damagePlayer(2); e.ttl=0; } if(e.ttl<=0)e.kind='dead'; }
    if(e.kind===ENK.HEX){ e.ttl-=dt; if(e.ttl>0 && Math.hypot(player.x-e.x,player.y-e.y)<1.0){ player.weakTimer=3000; toast('Weakened!'); e.ttl=0; } if(e.ttl<=0) e.kind='dead'; }
    if(e.kind===ENK.LOOT){ e.ttl-=dt; if(e.ttl<=0) e.kind='dead'; }
  });
  ents = ents.filter(e=>e.kind!=='dead');
}

/* ========= boss logic ========= */
function bossAI(dt){
  if(!boss) return;
  const dx=player.x-boss.x, dy=player.y-boss.y, d=Math.hypot(dx,dy);
  boss.cd-=dt;
  // patterns per phase
  if(boss.phase===1){ // slam/charge
    if(d>1.2){ boss.x+=dx/d*0.22*dt; boss.y+=dy/d*0.22*dt; }
    if(d<1.0 && boss.cd<=0){ damagePlayer(2); boss.cd=1300; }
  } else if(boss.phase===2){ // summon waves
    if(boss.cd<=0){ spawnEnemy(pickEnemy(Math.min(1,roomIdx/120))); boss.cd=1800; }
    if(d>1.3){ boss.x+=dx/d*0.18*dt; boss.y+=dy/d*0.18*dt; }
  } else { // phase 3: projectiles
    if(boss.cd<=0){ const ang=Math.atan2(dy,dx); for(let i=-2;i<=2;i++){ const th=ang+i*0.2; ents.push({kind:ENK.BOLT,x:boss.x,y:boss.y,vx:Math.cos(th)*0.35,vy:Math.sin(th)*0.35,ttl:240,dmg:2,fromEnemy:true}); } boss.cd=1500; }
    if(d>1.0){ boss.x+=dx/d*0.2*dt; boss.y+=dy/d*0.2*dt; }
  }
}
function nextBossPhaseOrDie(){
  if(boss.phase<boss.phases){ boss.phase++; boss.hp=boss.hpMax*0.7; toast('The boss enrages!'); }
  else {
    toast('Boss defeated!');
    dropLoot({x:boss.x,y:boss.y,kind:'boss'}, true); // infinite durability drop
    boss=null;
    if(Math.floor(roomIdx/50)>=3 && !npcShown){
      openPanel(`<h3>A survivor appears</h3><p>‚ÄúYou‚Äôve freed the dungeons. Yet the crawl continues‚Ä¶‚Äù</p>`,null);
      player.melee=true; player.meleeDur=999999; player.enchant='endless';
      player.ranged=true; player.rangedDur=999999;
      npcShown=true;
    }
  }
}

/* ========= damage & death ========= */
function damagePlayer(d){
  if(shieldBlocks>0){ shieldBlocks--; return; }
  player.hp=Math.max(0,player.hp-d);
  Audio.hurt();
}

/* ========= main loop ========= */
let last=nowMs();
function step(){
  const t=nowMs(), dt=Math.min(60, t-last); last=t;

  // hunger drain: 10 points, each ~60s ‚Üí bar drains in ~10*60s; we approximate:
  hungerTimer+=dt; if(hungerTimer>=6000){ hungerTimer=0; player.hunger=Math.max(0, player.hunger-0.1); }
  // energy regen (faster in pool)
  const onPool = map[Math.round(player.y)]?.[Math.round(player.x)]===T.POOL;
  const eRate = onPool? 0.4 : 0.08; player.energy=clamp(player.energy + eRate*dt, 0, player.energyMax);
  if(onPool && player.energy>=player.energyMax-1) Audio.heal();
  // hp regen only if hunger full
  if(player.hunger>=player.hungerMax-0.1){ hpRegenTimer+=dt; if(hpRegenTimer>1200){ hpRegenTimer=0; if(player.hp<player.hpMax){ player.hp++; Audio.heal(); } } } else hpRegenTimer=0;

  // combo slow recovers
  if(player.comboSlowTimer>0){ player.comboSlowTimer-=dt; if(player.comboSlowTimer<=0) player.spd=player.baseSpd; }
  if(player.weakTimer>0) player.weakTimer-=dt;

  // movement
  let dx=0,dy=0; if(keys['ArrowUp']||keys['w']) dy-=1; if(keys['ArrowDown']||keys['s']) dy+=1; if(keys['ArrowLeft']||keys['a']) dx-=1; if(keys['ArrowRight']||keys['d']) dx+=1;
  if(dx||dy){ const len=Math.hypot(dx,dy); dx/=len; dy/=len; player.facing=[dx,dy]; }
  const sp= player.spd*(player.energy<=0?0.5:1); const nx=player.x+dx*sp*dt/160, ny=player.y+dy*sp*dt/160;
  if(walkable(Math.round(nx),Math.round(player.y))) player.x=nx; if(walkable(Math.round(player.x),Math.round(ny))) player.y=ny;

  // door transition
  const tx=Math.round(player.x), ty=Math.round(player.y); const tile=map[ty][tx];
  if(tile===T.DOOR && !wavesActive && !boss){ roomIdx++; const isBoss=(roomIdx%50===0); regenRoom(isBoss); toast(isBoss?'A great power stirs below‚Ä¶':'Room '+roomIdx,1200); }

  // pick loot
  ents.forEach(e=>{
    if(e.kind===ENK.LOOT && Math.hypot(e.x-player.x,e.y-player.y)<0.7){
      if(e.what===LOOT.FOOD){ player.hunger=player.hungerMax; toast('You feast.'); Audio.pickup(); }
      if(e.what===LOOT.SWORD){ player.melee=true; player.meleeDur= (e.meta&&e.meta.ench==='endless')?999999:(e.meta?40:30); player.enchant=e.meta?.ench||player.enchant; toast('Sword acquired'+(player.enchant?` [${player.enchant}]`:'')+'.'); Audio.pickup(); }
      if(e.what===LOOT.XBOW){ player.ranged=true; player.rangedDur= (e.meta&&e.meta.ench==='endless')?999999:20; if(e.meta?.ench) player.enchant=e.meta.ench; toast('Crossbow acquired'+(player.enchant?` [${player.enchant}]`:'')+'.'); Audio.pickup(); }
      if(e.what===LOOT.SHIELD){ shieldBlocks+=3; toast('Shield shards +3'); Audio.pickup(); }
      if(e.what===LOOT.POT){ const p=e.meta?.pot||pickPotion(); toast('Potion: '+p); /* inventory-less: drink via Potions button */ }
      if(e.what===LOOT.ENCHANT){ player.melee=true; player.ranged=true; player.meleeDur=999999; player.rangedDur=999999; player.enchant='endless'; toast('Legendary gear (unbreaking)!'); }
      e.kind='dead';
    }
  });

  // dash cooldown
  if(player.dashCd>0){ player.dashCd-=dt; if(player.dashCd<=0){ player.dashCd=0; dashCdEl.style.display='none'; } else dashCdEl.textContent=Math.ceil(player.dashCd/1000)+'s'; }

  // enemies + boss
  enemyAI(dt); bossAI(dt);

  // wave manager
  if(wavesActive && ents.filter(e=>e.enemy).length===0){
    wavesLeft--; if(wavesLeft>0){ startWave(); } else { wavesActive=false; unlockExit(); toast('The seal fades.'); }
  }

  // death
  if(player.hp<=0){ return gameOver(); }

  // render
  cx.imageSmoothingEnabled=false; cx.clearRect(0,0,W,H); drawScene(); updateBars();
  requestAnimationFrame(step);
}

/* ========= game over ========= */
function gameOver(){
  openPanel(`<h3 style="color:#ff9aa2;margin:.2rem 0">You fall in the dark.</h3><p>Rooms cleared: ${roomIdx-1}</p><button class="choice" id="retry">Try Again</button>`);
  document.getElementById('retry').addEventListener('click',()=>{
    roomIdx=1; player.hp=player.hpMax; player.energy=player.energyMax; player.hunger=player.hungerMax; player.spd=player.baseSpd; player.enchant=null; player.melee=false; player.ranged=false; shieldBlocks=0; npcShown=false;
    regenRoom(false); panel.style.display='none';
  });
}

/* ========= start ========= */
document.getElementById('startBtn').addEventListener('click',async()=>{ await Audio.resume(); document.getElementById('intro').remove(); regenRoom(false); requestAnimationFrame(step); });
updateBars();
</script>
</body>
</html>
