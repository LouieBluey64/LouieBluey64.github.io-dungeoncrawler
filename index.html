<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Crypt Unending ‚Äî Touch Build</title>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<style>
  :root{
    --bg:#0b0b0e; --floor:#121216; --grout:#0f1016; --wall:#1b1b21; --wallHi:#25252e; --wallSd:#0d0e12;
    --torch:#ffbd6a; --torch2:#ff9e42; --pool1:#0a2233; --pool2:#184a6e; --drip:#1a2533;
    --bone:#e0dccf; --blood:#b52c3b; --ui:#26262f; --ui2:#1a1a22;
  }
  html,body{margin:0;height:100%;background:var(--bg);color:#eee;font-family:ui-rounded,system-ui,-apple-system,Segoe UI,Roboto,sans-serif;overflow:hidden}
  #cv{display:block;width:100vw;height:100vh;background:var(--bg);image-rendering:pixelated;touch-action:none}
  #hud{position:fixed;inset:0;pointer-events:none}
  .bar{height:10px;width:180px;background:#111;border:1px solid #2b2b33;border-radius:4px;position:absolute}
  .fill{position:absolute;inset:0;width:100%}
  #hpT{left:10px;top:8px;font-weight:900}
  #hpB{left:84px;top:8px}.hpF{background:linear-gradient(180deg,#c23,#821b25)}
  #enB{left:84px;top:24px}.enF{background:linear-gradient(180deg,#4bb7ff,#2a6fa3)}
  #huB{left:84px;top:40px}.huF{background:linear-gradient(180deg,#7bbd4a,#46752c)}
  #roomT{position:absolute;right:10px;top:8px;font-weight:900;color:#cfd2e6}
  #coinsT{position:absolute;right:10px;top:26px;color:#ffdf84;font-weight:900}
  .pad{position:absolute;pointer-events:auto}
  .btn{width:64px;height:64px;border-radius:12px;background:rgba(255,255,255,.08);border:1px solid #3a3a45;color:#e8e8f0;display:flex;align-items:center;justify-content:center;font-size:26px}
  #btnMelee{right:12px;bottom:16px}
  #btnRanged{right:12px;bottom:92px}
  #btnInteract{right:92px;bottom:132px}
  #btnInv{right:92px;bottom:56px}
  #msg{position:fixed;left:50%;top:10px;transform:translateX(-50%);background:#111a;border:1px solid #2a2a33;border-radius:10px;padding:.35rem .7rem;display:none}
  #panel{position:fixed;inset:0;background:#0009;display:none;align-items:center;justify-content:center}
  .card{background:linear-gradient(180deg,#15151a,#0f0f14);border:1px solid #2a2a33;border-radius:14px;padding:16px;max-width:640px;color:#ddd}
  .choices{display:flex;flex-wrap:wrap;gap:.6rem;margin-top:.6rem}
  .choice{pointer-events:auto;padding:.5rem .7rem;border:1px solid #3a3a45;border-radius:10px;background:#141418;cursor:pointer}
  .choice:active{transform:translateY(1px)}
  #invGrid{display:grid;grid-template-columns:repeat(5,44px);gap:6px;margin-top:.6rem}
  .slot{width:44px;height:44px;background:#0d0d12;border:1px solid #2b2b33;border-radius:8px;display:flex;align-items:center;justify-content:center}
</style>
</head>
<body>
<canvas id="cv" width="320" height="180"></canvas>

<div id="hud">
  <div id="hpT">‚ô• <span id="hpVal">10</span>/10</div>
  <div id="hpB" class="bar"><div id="hpF" class="fill hpF"></div></div>
  <div id="enB" class="bar"><div id="enF" class="fill enF"></div></div>
  <div id="huB" class="bar"><div id="huF" class="fill huF"></div></div>
  <div id="roomT">Room 1</div>
  <div id="coinsT">ü™ô 0</div>

  <button id="btnMelee" class="pad btn" aria-label="Melee">üó°Ô∏è</button>
  <button id="btnRanged" class="pad btn" aria-label="Ranged">üèπ</button>
  <button id="btnInteract" class="pad btn" aria-label="Interact">‚úã</button>
  <button id="btnInv" class="pad btn" aria-label="Inventory">üéí</button>
</div>

<div id="msg"></div>
<div id="panel"><div class="card" id="panelC"></div></div>

<script>
/* ===== helpers / canvas ===== */
const rand=(a,b)=>Math.random()*(b-a)+a, rint=(a,b)=>Math.floor(rand(a,b+1)), clamp=(v,a,b)=>v<a?a:(v>b?b:v), chance=p=>Math.random()<p;
const cv=document.getElementById('cv'), cx=cv.getContext('2d');
let W=cv.width,H=cv.height,SCALE=3;
function fit(){const vw=innerWidth,vh=innerHeight;SCALE=Math.max(1,Math.floor(Math.min(vw/W,vh/H)));cv.style.width=W*SCALE+'px';cv.style.height=H*SCALE+'px';}
addEventListener('resize',fit); addEventListener('orientationchange',fit); fit();

/* dual buffers */
const TILES_W=320,TILES_H=180; const tiles=document.createElement('canvas'); tiles.width=TILES_W; tiles.height=TILES_H; const gt=tiles.getContext('2d');
const SPR_W=160,SPR_H=90; const spr=document.createElement('canvas'); spr.width=SPR_W; spr.height=SPR_H; const gs=spr.getContext('2d');

/* UI refs */
const hpVal=document.getElementById('hpVal'), hpF=document.getElementById('hpF'), enF=document.getElementById('enF'), huF=document.getElementById('huF');
const roomT=document.getElementById('roomT'), coinsT=document.getElementById('coinsT');
const msg=document.getElementById('msg'); let msgTo=0;
function toast(t,ms=1200){ msg.textContent=t; msg.style.display='block'; clearTimeout(msgTo); msgTo=setTimeout(()=>msg.style.display='none',ms); }

/* audio */
const SFX=(()=>{const C=new (window.AudioContext||window.webkitAudioContext)();let ok=false;
async function start(){if(C.state!=='running'){try{await C.resume();}catch{}}ok=true;}
function blip(f=500,d=0.07,v=0.2,t='square'){if(!ok)return;const o=C.createOscillator(),g=C.createGain();o.type=t;o.frequency.value=f;g.gain.value=v;o.connect(g);g.connect(C.destination);const n=C.currentTime;o.start(n);g.gain.exponentialRampToValueAtTime(0.0001,n+d);o.stop(n+d+0.02);}
return{start,hit:()=>blip(520,0.06,0.22,'square'),dash:()=>blip(140,0.1,0.25,'sine'),hurt:()=>blip(160,0.12,0.3,'triangle'),pick:()=>blip(880,0.07,0.22,'square'),coin:()=>blip(740,0.06,0.22,'square'),heal:()=>blip(900,0.1,0.25,'sine')};})();

/* constants, map, entities */
const TILE=16,RW=22,RH=14;
const T={FLOOR:0,WALL:1,TORCH:2,POOL:3,DRIP:4,DOOR:5,LOCK:6,CHEST:7,LEVER:8,SECRETD:9,ANVIL:10,TRADER:11};
const EN={SLIME:'slime',SKEL:'skeleton',ARCH:'archer',BRUTE:'brute',BAT:'bat'};
const IT={FOOD:'food',SWORD:'sword',XBOW:'xbow',POT:'pot',COIN:'coin',SHIELD:'shield',RELIC:'relic'};

let room=1, map=[], ents=[], coins=0;

/* player */
const player={x:RW/2,y:RH/2,spd:3.0,base:3.0,hp:10,hpMax:10,energy:100,energyMax:100,hunger:10,hungerMax:10,face:[1,0],dashCd:0,melee:false,meleeDur:0,ranged:false,rangedDur:0,inv:[]};
function equipSword(dur=30){player.melee=true;player.meleeDur=dur;}
function equipBow(dur=20){player.ranged=true;player.rangedDur=dur;}

/* input: drag to move, swipe to dash */
let drag=null;
cv.addEventListener('touchstart',e=>{ if(e.touches.length===1){const t=e.touches[0];drag={sx:t.clientX,sy:t.clientY,px:t.clientX,py:t.clientY,ts:performance.now()};}}, {passive:true});
cv.addEventListener('touchmove',e=>{ if(!drag)return; const t=e.touches[0]; drag.px=t.clientX; drag.py=t.clientY; }, {passive:true});
cv.addEventListener('touchend',e=>{ if(!drag)return; const dx=drag.px-drag.sx, dy=drag.py-drag.sy, dist=Math.hypot(dx,dy); const dt=performance.now()-drag.ts; if(dist>70 && dt<300){ doDash(Math.atan2(dy,dx)); } else { setMoveTarget(drag.px,drag.py); } drag=null; }, {passive:true});

let moveTarget=null;
/* safer screen->world mapping */
function setMoveTarget(cxScr,cyScr){
  const rect=cv.getBoundingClientRect();
  const cx=(cxScr-rect.left)/SCALE, cy=(cyScr-rect.top)/SCALE; // canvas pixels
  const camX=player.x*TILE - W/2, camY=player.y*TILE - H/2;
  moveTarget={x:(camX+cx)/TILE, y:(camY+cy)/TILE};
}

/* right buttons */
document.getElementById('btnMelee').onclick=()=>melee();
document.getElementById('btnRanged').onclick=()=>ranged();
document.getElementById('btnInteract').onclick=()=>interact();
document.getElementById('btnInv').onclick=()=>openInventory();

/* generation */
function regen(){
  map=Array.from({length:RH},()=>Array(RW).fill(T.FLOOR));
  for(let y=0;y<RH;y++)for(let x=0;x<RW;x++){ if(x===0||y===0||x===RW-1||y===RH-1) map[y][x]=T.WALL; }
  for(let i=0;i<rint(20,36);i++){ const x=rint(2,RW-3), y=rint(2,RH-3); map[y][x]= chance(0.7)?T.WALL:T.DRIP; }
  for(let i=0;i<rint(4,6);i++){ const side=rint(0,3); let x=1,y=1; if(side===0){x=rint(3,RW-4);y=1}else if(side===1){x=rint(3,RW-4);y=RH-2}else if(side===2){x=1;y=rint(3,RH-4)}else{x=RW-2;y=rint(3,RH-4)}; map[y][x]=T.TORCH; }
  const side=rint(0,3); if(side===0) map[0][rint(4,RW-5)]=T.DOOR; else if(side===1) map[RH-1][rint(4,RW-5)]=T.DOOR; else if(side===2) map[rint(4,RH-5)][0]=T.DOOR; else map[rint(4,RH-5)][RW-1]=T.DOOR;
  if(room%10===0){ map[rint(3,RH-4)][rint(3,RW-4)]=T.POOL; map[rint(4,RH-5)][rint(4,RW-5)]=T.ANVIL; } else if(chance(0.25)) map[rint(3,RH-4)][rint(3,RW-4)]=T.POOL;
  if(chance(0.35)){ const sx=rint(3,RW-4), sy=rint(3,RH-4); map[sy][sx]=T.SECRETD; const lx=Math.max(2,Math.min(RW-3,sx+rint(-3,3))), ly=Math.max(2,Math.min(RH-3,sy+rint(-3,3))); map[ly][lx]=T.LEVER; }
  if(chance(0.4)) map[rint(3,RH-4)][rint(3,RW-4)]=T.CHEST;
  if(chance(0.10)) map[rint(3,RH-4)][rint(3,RW-4)]=T.TRADER;
  const depth=Math.min(1,(room-1)/120), n=rint(1,2+Math.round(depth*4));
  for(let i=0;i<n;i++) spawnEnemy(pickEnemy(depth));
  player.x=RW/2; player.y=RH/2; moveTarget=null;
}
function pickEnemy(d){ const bag=[[EN.SLIME,0.45-0.3*d],[EN.SKEL,0.35+0.2*d],[EN.ARCH,0.1+0.1*d],[EN.BAT,0.05+0.1*d],[EN.BRUTE,0.05+0.12*d]].filter(b=>b[1]>0.001); let s=bag.reduce((a,b)=>a+b[1],0), r=Math.random()*s; for(const [k,w] of bag){ if((r-=w)<=0) return k; } return EN.SLIME; }
function spawnEnemy(kind){ const e={kind,enemy:true,x:rint(2,RW-3),y:rint(2,RH-3),hp:1,spd:0.5,cd:0}; if(kind===EN.SLIME){e.hp=1;e.spd=.45;} if(kind===EN.SKEL){e.hp=3;e.spd=.6;} if(kind===EN.ARCH){e.hp=2;e.spd=.55;e.ranged=true;} if(kind===EN.BAT){e.hp=1;e.spd=.9;e.fly=true;} if(kind===EN.BRUTE){e.hp=5;e.spd=.45;e.dmg=2;} ents.push(e); }

/* tiles & draw */
function tileAt(x,y){ if(y<0||y>=RH||x<0||x>=RW) return T.WALL; return map[y][x]; }
function walkable(tx,ty){ const t=tileAt(tx,ty); return t!==T.WALL && t!==T.SECRETD; }
function drawTiles(camX,camY){
  const css=n=>getComputedStyle(document.documentElement).getPropertyValue(n);
  gt.imageSmoothingEnabled=false; gt.fillStyle=css('--bg'); gt.fillRect(0,0,TILES_W,TILES_H);
  for(let y=0;y<RH;y++)for(let x=0;x<RW;x++){
    const t=map[y][x], px=Math.floor(x*TILE - camX), py=Math.floor(y*TILE - camY);
    gt.fillStyle=css('--floor'); gt.fillRect(px,py,TILE,TILE);
    gt.fillStyle=css('--grout'); if(((x^y)&3)===0) gt.fillRect(px+TILE-2,py+TILE-2,1,1);
    if(t===T.TORCH){ gt.globalAlpha=.22; gt.fillStyle=css('--torch'); gt.fillRect(px-8,py-8,TILE+16,TILE+16); gt.globalAlpha=1; }
  }
  for(let y=0;y<RH;y++)for(let x=0;x<RW;x++){
    const t=map[y][x], px=Math.floor(x*TILE - camX), py=Math.floor(y*TILE - camY);
    if(t===T.WALL||t===T.SECRETD){ gt.fillStyle=css('--wall'); gt.fillRect(px,py,TILE,TILE); gt.fillStyle=css('--wallHi'); gt.fillRect(px,py,TILE,3); gt.fillStyle=css('--wallSd'); gt.fillRect(px,py+TILE-3,TILE,3); gt.fillStyle=css('--grout'); gt.fillRect(px+8,py,1,TILE); }
    if(t===T.DRIP){ gt.fillStyle=css('--drip'); gt.fillRect(px+9,py+2,2,TILE-4); }
    if(t===T.POOL){ gt.fillStyle=css('--pool1'); gt.fillRect(px+2,py+3,12,11); gt.fillStyle=css('--pool2'); gt.fillRect(px+3,py+6,10,6); }
    if(t===T.CHEST){ gt.fillStyle='#3a2816'; gt.fillRect(px+3,py+8,10,6); gt.fillStyle='#714b22'; gt.fillRect(px+3,py+5,10,4); gt.fillStyle='#cfa85b'; gt.fillRect(px+7,py+9,2,2); }
    if(t===T.LEVER){ gt.fillStyle='#444'; gt.fillRect(px+6,py+6,4,8); gt.fillStyle='#cfa85b'; gt.fillRect(px+5,py+5,6,2); }
    if(t===T.TORCH){ gt.fillStyle='#3a2a12'; gt.fillRect(px+6,py+4,4,10); gt.fillStyle=Math.random()>.5?css('--torch'):css('--torch2'); gt.fillRect(px+6,py+2,4,3); }
    if(t===T.DOOR){ gt.fillStyle='#231a12'; gt.fillRect(px,py,TILE,TILE); gt.fillStyle='#5a3a20'; gt.fillRect(px+4,py+2,8,12); }
    if(t===T.LOCK){ gt.fillStyle='#180e10'; gt.fillRect(px,py,TILE,TILE); gt.fillStyle='#3a2420'; gt.fillRect(px+4,py+2,8,12); gt.fillStyle='#cfa85b'; gt.fillRect(px+7,py+7,2,2); }
    if(t===T.ANVIL){ gt.fillStyle='#2e2f38'; gt.fillRect(px+4,py+8,8,6); gt.fillStyle='#4a4b58'; gt.fillRect(px+3,py+6,10,3); }
    if(t===T.TRADER){ gt.fillStyle='#113015'; gt.fillRect(px,py,TILE,TILE); gt.fillStyle='#cfa85b'; gt.fillRect(px+5,py+6,6,6); }
  }
}
function drawSprites(camX,camY){
  gs.imageSmoothingEnabled=false; gs.clearRect(0,0,SPR_W,SPR_H);
  const s=SPR_W/W, toS=v=>Math.floor(v*s);
  const px=toS(W/2), py=toS(H/2);
  gs.fillStyle=getComputedStyle(document.documentElement).getPropertyValue('--bone'); gs.fillRect(px-4,py-6,8,10);
  gs.fillStyle='#9d9b90'; gs.fillRect(px-4,py-8,8,3);
  ents.forEach(e=>{
    const ex=toS(e.x*TILE - camX), ey=toS(e.y*TILE - camY);
    if(e.enemy){
      if(e.kind===EN.SLIME){ gs.fillStyle='#233'; gs.fillRect(ex-5,ey-4,10,8); gs.fillStyle='#355'; gs.fillRect(ex-5,ey-6,10,2); }
      if(e.kind===EN.SKEL){ gs.fillStyle=getComputedStyle(document.documentElement).getPropertyValue('--bone'); gs.fillRect(ex-4,ey-6,8,10); gs.fillStyle='#555'; gs.fillRect(ex-4,ey-8,8,3); }
      if(e.kind===EN.ARCH){ gs.fillStyle='#d2c9b8'; gs.fillRect(ex-4,ey-6,8,10); gs.fillStyle='#4a3a2a'; gs.fillRect(ex-4,ey-8,8,3); gs.fillStyle='#885522'; gs.fillRect(ex+3,ey-2,2,6); }
      if(e.kind===EN.BAT){ gs.fillStyle='#2a2a33'; gs.fillRect(ex-3,ey-3,6,6); gs.fillRect(ex-7,ey-1,4,2); gs.fillRect(ex+3,ey-1,4,2); }
      if(e.kind===EN.BRUTE){ gs.fillStyle='#4b2a2f'; gs.fillRect(ex-6,ey-6,12,12); gs.fillStyle='#8c3a45'; gs.fillRect(ex-6,ey-8,12,3); }
    } else {
      if(e.kind==='bolt'){ gs.fillStyle='#bcd1ff'; gs.fillRect(ex-1,ey-1,2,2); }
      if(e.kind==='loot'){ let c='#666'; if(e.what===IT.FOOD)c='#79c36a'; if(e.what===IT.SWORD)c='#cfa85b'; if(e.what===IT.XBOW)c='#c9d4ff'; if(e.what===IT.SHIELD)c='#9ea0b5'; if(e.what===IT.POT)c='#b98cff'; if(e.what===IT.COIN)c='#ffd26a'; if(e.what===IT.RELIC)c='#ffdf84'; gs.fillStyle=c; gs.fillRect(ex-3,ey-3,6,6); }
    }
  });
}

/* bars */
function bars(){ hpVal.textContent=Math.round(player.hp); hpF.style.width=(player.hp/player.hpMax*100)+'%'; enF.style.width=(player.energy/player.energyMax*100)+'%'; huF.style.width=(player.hunger/player.hungerMax*100)+'%'; roomT.textContent='Room '+room; coinsT.textContent='ü™ô '+coins; }

/* panel / inventory */
const panel=document.getElementById('panel'), panelC=document.getElementById('panelC');
function openPanel(html,choices){
  panelC.innerHTML=html+(choices?`<div class="choices">${choices.map((c,i)=>`<button class="choice" data-i="${i}">${c.label}</button>`).join('')}</div>`:'');
  panel.style.display='flex';
  if(choices){ panelC.querySelectorAll('.choice').forEach((b,i)=>b.onclick=()=>{panel.style.display='none';choices[i].on();}); }
  else panel.onclick=()=>panel.style.display='none';
}
function iconFor(w){ return w===IT.FOOD?'üçó':w===IT.SWORD?'üó°Ô∏è':w===IT.XBOW?'üèπ':w===IT.POT?'üß™':w===IT.SHIELD?'üõ°Ô∏è':w===IT.RELIC?'‚ú®':'‚Ä¢' }
function giveItem(what,opt={}){ player.inv.push({what,...opt}); toast(`Got ${what}`); SFX.pick(); }
function openInventory(){
  const grid=player.inv.map(it=>`<div class="slot">${iconFor(it.what)}</div>`).join('');
  openPanel(`<h3>Inventory</h3><div id="invGrid">${grid}</div><p>Tap a slot to use/equip.</p>`);
  panelC.querySelectorAll('.slot').forEach((n,i)=>n.onclick=()=>{ useItem(i); panel.style.display='none'; });
}
function useItem(i){
  const it=player.inv[i]; if(!it) return;
  if(it.what===IT.FOOD){ player.hunger=player.hungerMax; SFX.heal(); }
  if(it.what===IT.SWORD){ equipSword(30); }
  if(it.what===IT.XBOW){ equipBow(20); }
  if(it.what===IT.SHIELD){ player.shield=(player.shield||0)+3; }
  if(it.what===IT.POT){
    const r=rint(0,4);
    if(r===0) player.spd=player.base+1.2, setTimeout(()=>player.spd=player.base,20000);
    if(r===1) player.hp=Math.min(player.hpMax,player.hp+2);
    if(r===2) player.energy=player.energyMax;
    if(r===3) player.hunger=player.hungerMax;
    if(r===4) player.melee && (player.meleeDur+=10);
  }
  if(it.what===IT.RELIC){ player.melee=true; player.meleeDur=999999; player.ranged=true; player.rangedDur=999999; }
  player.inv.splice(i,1); bars();
}

/* combat */
function melee(){
  SFX.hit();
  const dmg=player.melee?2:1;
  ents.forEach(e=>{ if(e.enemy && Math.hypot(e.x-player.x,e.y-player.y)<1.2){ e.hp-=dmg; if(e.hp<=0) die(e); } });
  if(player.melee && player.meleeDur<999999){ if(--player.meleeDur<=0){ player.melee=false; toast('Sword broke'); } }
}
function ranged(){
  if(!player.ranged){ toast('No crossbow yet'); return; }
  let best=null,bd=999;
  ents.forEach(e=>{ if(e.enemy){ const d=Math.hypot(e.x-player.x,e.y-player.y); if(d>=5 && d<bd){ bd=d; best=e; } } });
  if(!best){ toast('Must be ‚â•5 tiles away'); return; }
  const ang=Math.atan2(best.y-player.y,best.x-player.x);
  ents.push({kind:'bolt',x:player.x,y:player.y,vx:Math.cos(ang)*0.5,vy:Math.sin(ang)*0.5,ttl:240,dmg:3});
  if(player.rangedDur<999999){ if(--player.rangedDur<=0){ player.ranged=false; toast('Crossbow snapped'); } }
}
function doDash(ang){
  if(player.dashCd>0 || player.energy<20){ toast('Dash cooling / tired'); return; }
  SFX.dash();
  const dir=ang!=null?[Math.cos(ang),Math.sin(ang)]:player.face[0]||player.face[1]?player.face:[1,0];
  const tx=player.x+dir[0]*1.6, ty=player.y+dir[1]*1.6;
  if(walkable(Math.round(tx),Math.round(player.y))) player.x=tx;
  if(walkable(Math.round(player.x),Math.round(ty))) player.y=ty;
  ents.forEach(e=>{ if(e.enemy && Math.hypot(e.x-player.x,e.y-player.y)<1.2){ e.hp-=2; if(e.hp<=0) die(e); }});
  player.energy=Math.max(0,player.energy-20); player.dashCd=900;
}

/* interact */
function interact(){
  const px=Math.round(player.x), py=Math.round(player.y); let did=false;
  for(let y=py-1;y<=py+1;y++)for(let x=px-1;x<=px+1;x++){
    const t=tileAt(x,y);
    if(t===T.LEVER){ map[y][x]=T.FLOOR; 
      for(let yy=1;yy<RH-1;yy++)for(let xx=1;xx<RW-1;xx++) if(map[yy][xx]===T.SECRETD){ map[yy][xx]=T.FLOOR; toast('Stone slides‚Ä¶'); did=true; break; }
      if(!did) toast('The lever clanks.'); did=true;
    } else if(t===T.CHEST){ openChest(x,y); map[y][x]=T.FLOOR; did=true; }
      else if(t===T.SECRETD){ map[y][x]=T.FLOOR; toast('Hidden seam opens'); did=true; }
      else if(t===T.TRADER){ openTrader(); did=true; }
      else if(t===T.ANVIL){ openAnvil(); did=true; }
      else if(t===T.POOL){ player.hp=player.hpMax; player.hunger=player.hungerMax; player.energy=player.energyMax; SFX.heal(); toast('You feel renewed'); did=true; }
  }
  if(!did) toast("There's nothing there");
}
function openChest(){
  const roll=Math.random();
  if(roll<0.35) giveItem(IT.FOOD);
  else if(roll<0.55) giveItem(IT.SWORD);
  else if(roll<0.7) giveItem(IT.XBOW);
  else if(roll<0.85) giveItem(IT.POT);
  else giveItem(IT.SHIELD);
}
function openTrader(){
  const trades=[
    {label:'Buy Sword (ü™ô 8)', cost:8, give:IT.SWORD},
    {label:'Buy Crossbow (ü™ô 10)', cost:10, give:IT.XBOW},
    {label:'Buy Potion (ü™ô 5)', cost:5, give:IT.POT},
    {label:'Sell Food (ü™ô +2)', sell:IT.FOOD, gain:2},
    {label:'Sell Shield (ü™ô +4)', sell:IT.SHIELD, gain:4},
  ];
  openPanel(`<h3>Wandering Trader</h3><p>Coins: ${coins}</p>`,
    trades.map(t=>({label:t.label,on:()=>{ 
      if(t.give){ if(coins>=t.cost){ coins-=t.cost; giveItem(t.give); } else toast('Not enough coins'); }
      else if(t.sell){ const idx=player.inv.findIndex(i=>i.what===t.sell); if(idx>-1){ player.inv.splice(idx,1); coins+=t.gain; SFX.coin(); } else toast('You lack that item'); }
      bars();
    }}))
  );
}
function openAnvil(){
  const A={what:IT.SWORD, stats:'+2 dmg, durability 40'};
  const B={what:IT.XBOW, stats:'fast draw, durability 25'};
  openPanel(`<h3>Smith‚Äôs Anvil</h3><p style="background:#0b0b0e;border:1px solid #2b2b33;padding:.5rem;border-radius:8px">Choose your path:</p>`,
    [{label:`A) üó°Ô∏è Sword ‚Äî ${A.stats}`,on:()=>{giveItem(IT.SWORD);}},
     {label:`B) üèπ Crossbow ‚Äî ${B.stats}`,on:()=>{giveItem(IT.XBOW);}}]
  );
}

/* AI & damage */
function die(e){
  let c=1; if(e.kind===EN.SKEL)c=2; if(e.kind===EN.ARCH)c=3; if(e.kind===EN.BRUTE)c=4;
  coins+=c; SFX.coin();
  if(chance(0.1)) ents.push({kind:'loot',what:IT.POT,x:e.x,y:e.y,ttl:8000});
  e.enemy=false; e.dead=true;
}
function ai(dt){
  ents.forEach(e=>{
    if(e.enemy){
      const dx=player.x-e.x, dy=player.y-e.y, d=Math.hypot(dx,dy)||1;
      const sp=e.spd*dt/220;
      const nx=e.x+dx/d*sp, ny=e.y+dy/d*sp;
      if(walkable(Math.round(nx),Math.round(e.y))) e.x=nx;
      if(walkable(Math.round(e.x),Math.round(ny))) e.y=ny;
      e.cd-=dt;
      if(e.ranged && e.cd<=0 && d>4){ const a=Math.atan2(dy,dx); ents.push({kind:'bolt',x:e.x,y:e.y,vx:Math.cos(a)*0.35,vy:Math.sin(a)*0.35,ttl:240,dmg:1}); e.cd=1100; }
      if(d<0.9 && e.cd<=0){ damage(1); e.cd=900; }
    } else {
      if(e.kind==='bolt'){
        e.x+=e.vx*dt; e.y+=e.vy*dt; e.ttl-=dt;
        if(Math.hypot(player.x-e.x,player.y-e.y)<0.7 && e.dmg){ damage(e.dmg); e.ttl=0; }
        ents.forEach(t=>{ if(t.enemy && Math.hypot(t.x-e.x,t.y-e.y)<0.6 && !e.fromEnemy){ t.hp-=e.dmg; e.ttl=0; if(t.hp<=0) die(t);} });
        if(e.ttl<=0) e.dead=true;
      }
      if(e.kind==='loot'){ e.ttl-=dt; if(e.ttl<=0) e.dead=true; if(Math.hypot(e.x-player.x,e.y-player.y)<0.7){ giveItem(e.what); e.dead=true; } }
    }
  });
  ents=ents.filter(e=>!e.dead);
}
function damage(n){ if(player.shield>0){player.shield--;return;} player.hp=Math.max(0,player.hp-n); SFX.hurt(); }

/* loop */
let last=performance.now();
function tick(){
  const t=performance.now(), dt=Math.min(60,t-last); last=t;

  // survival meters
  player.hunger=Math.max(0, player.hunger - dt/60000*10);
  const onPool=tileAt(Math.round(player.x),Math.round(player.y))===T.POOL;
  player.energy=clamp(player.energy+(onPool?0.5:0.08)*dt,0,player.energyMax);
  if(player.hunger>=player.hungerMax-0.1 && player.hp<player.hpMax){ player.hp=Math.min(player.hpMax, player.hp+dt/1500); }
  if(player.dashCd>0) player.dashCd-=dt;

  // movement toward target
  if(moveTarget){
    const dx=moveTarget.x-player.x, dy=moveTarget.y-player.y, d=Math.hypot(dx,dy);
    if(d>0.05){
      const dirx=dx/d, diry=dy/d; player.face=[dirx,diry];
      const sp=player.spd*(player.energy<=0?0.5:1);
      const nx=player.x+dirx*sp*dt/160, ny=player.y+diry*sp*dt/160;
      if(walkable(Math.round(nx),Math.round(player.y))) player.x=nx;
      if(walkable(Math.round(player.x),Math.round(ny))) player.y=ny;
    } else moveTarget=null;
  }

  // door ‚Üí next room
  const tx=Math.round(player.x), ty=Math.round(player.y);
  if(tileAt(tx,ty)===T.DOOR){ room++; regen(); toast('Room '+room); }

  ai(dt);

  // render
  const camX=player.x*TILE - W/2, camY=player.y*TILE - H/2;
  drawTiles(camX,camY); drawSprites(camX,camY);
  cx.imageSmoothingEnabled=false; cx.clearRect(0,0,W,H);
  cx.drawImage(tiles,0,0,W,H); cx.drawImage(spr,0,0,W,H);
  // vignette
  cx.globalAlpha=.55; const g=cx.createRadialGradient(W/2,H/2,W*.25,W/2,H/2,W*.75);
  g.addColorStop(0,'rgba(0,0,0,0)'); g.addColorStop(1,'rgba(0,0,0,1)');
  cx.fillStyle=g; cx.fillRect(0,0,W,H); cx.globalAlpha=1;

  bars();
  if(player.hp<=0){
    openPanel(`<h3 style="color:#ff9aa2">You fell in the dark</h3><p>Rooms cleared: ${room-1}</p>`,
      [{label:'Retry',on:()=>{ room=1; coins=0; Object.assign(player,{hp:10,hunger:10,energy:100,inv:[],melee:false,ranged:false}); regen(); panel.style.display='none'; }}]);
    return;
  }
  requestAnimationFrame(tick);
}

/* ==== AUTO-START ==== */
window.addEventListener('load', ()=>{ regen(); requestAnimationFrame(tick); });
// enable audio on first interaction (game already running)
cv.addEventListener('pointerdown', function once(){ try{SFX.start();}catch{} cv.removeEventListener('pointerdown', once); }, {passive:true});

hpVal.textContent='10';
</script>
</body>
</html>
